# Create a curved line from x = -157 to -90, y from -45 to 45
curve_data <- data.frame(
  x = seq(-157, -90, length.out = 100),
  y = 45 * sin(seq(-pi / 2, pi / 2, length.out = 100))  # y goes -45 to 45
)

arc_df <- data.frame(
  x0 = -123.5,        # center x (midpoint between -157 and -90)
  y0 = 0,             # center y (middle of -45 to 45)
  r = 33.5,           # radius = half the distance between -157 and -90
  start = -pi/2,      # -90 degrees
  end = pi/2          # +90 degrees
)


# Base plot with curve
ggplot() +
  # geom_path(data = curve_data, aes(x = x, y = y), color = "red", size = 1.2) +
  geom_arc(data = arc_df, aes(x0 = x0, y0 = y0, r = r, start = start, end = end),
           color = "red", size = 1.5) +
  coord_map("mollweide") +
  coord_map("mollweide") +  # projection type
  scale_x_continuous(limits = c(-180, 180), breaks = seq(-180, 180, 45)) +
  scale_y_continuous(limits = c(-90, 90), breaks = seq(-90, 90, 30)) +
  labs(
    title = "Seam Orientation in Mollweide Projection",
    subtitle = "Using TrackMan 3D Spin (h, v) Angles",
    x = "Horizontal Angle (°)",
    y = "Vertical Angle (°)",
    color = "Pitch Type"
  ) +
  theme_minimal()





### From Tom Tango Paper
# Seam curve generation
a <- 0.4
t_vals <- seq(0, 2 * pi, length.out = 1000)

y <- (1 - a) * cos(t_vals) * sin(2 * t_vals) + a * sin(t_vals)
z <- (1 - a) * sin(t_vals) * sin(2 * t_vals) + a * cos(t_vals)
x <- sign(cos(2 * t_vals)) * sqrt(1 - y^2 - z^2)

lon <- (180 / pi) * atan2(z, x)
lat <- (180 / pi) * asin(y)
base_seam <- data.frame(lon = lon, lat = lat)

# Duplicate and offset by -360, 0, +360 degrees to complete wrap
seam_df <- bind_rows(
  base_seam %>% mutate(lon = lon - 360),
  base_seam,
  base_seam %>% mutate(lon = lon + 360)
)


# Filter to display only within [-180, 180] after wrapping
seam_df <- seam_df %>% filter(lon >= -180 & lon <= 180)








# Your defined seam control points
seam_points <- data.frame(
  lon = c(-157, -90, 0, 90, 157, 90, 0, -90, -157),
  lat = c(   0,  45, 22.5, 45,   0, -45, -22.5, -45,   0)
)

# Step 1: Create a parametric variable t (like time)
t <- seq_along(seam_points$lon)

# Step 2: Interpolate lon and lat as functions of t
interp_n <- 300
t_interp <- seq(min(t), max(t), length.out = interp_n)

lon_spline <- spline(t, seam_points$lon, xout = t_interp)$y
lat_spline <- spline(t, seam_points$lat, xout = t_interp)$y

spline_curve <- data.frame(lon = lon_spline, lat = lat_spline)



